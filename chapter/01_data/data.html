<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>1&nbsp; Machine learning needs data – NLP: From Simple to Spectacular</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../chapter/02_baseline/baseline_classifier.html" rel="next">
<link href="../../intro.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


</head>

<body class="nav-sidebar floating slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../chapter/01_data/data.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Machine learning needs data</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">NLP: From Simple to Spectacular</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapter/01_data/data.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Machine learning needs data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapter/02_baseline/baseline_classifier.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Baseline: gotta start somewhere</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapter/bonus/cleaning_data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Bonus: cleaning data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#quality-vs.-quantity" id="toc-quality-vs.-quantity" class="nav-link active" data-scroll-target="#quality-vs.-quantity"><span class="header-section-number">1.1</span> Quality vs.&nbsp;quantity</a></li>
  <li><a href="#the-dataset" id="toc-the-dataset" class="nav-link" data-scroll-target="#the-dataset"><span class="header-section-number">1.2</span> The dataset</a></li>
  <li><a href="#classification-dataset" id="toc-classification-dataset" class="nav-link" data-scroll-target="#classification-dataset"><span class="header-section-number">1.3</span> Classification dataset</a></li>
  <li><a href="#unsupervised-dataset" id="toc-unsupervised-dataset" class="nav-link" data-scroll-target="#unsupervised-dataset"><span class="header-section-number">1.4</span> Unsupervised dataset</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">1.5</span> Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Machine learning needs data</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Without data, machine learning is nothing. After all what will it learn if it has nothing to learn from. Think about everything you’ve learned throughout your life. All the books you’ve read, the movies you’ve watched, the experiences you’ve lived. Everything you’ve touched, tasted, heard, felt, smelled. It all comes together to shape who you are and what you know. Our brains adapt and change to all of this input. Our brains <em>learn</em>. Take away all of the memories and experiences and what are we left with? Thoughts maybe, but of what? Without the context of our life there isn’t much to think about. Machine learning models work like our brain, but simpler. They take data and try to make sense of it, or <em>learn</em> from it. The more data, the easier it is to learn from, at least in theory.</p>
<section id="quality-vs.-quantity" class="level2 page-columns page-full" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="quality-vs.-quantity"><span class="header-section-number">1.1</span> Quality vs.&nbsp;quantity</h2>
<p>While we will dive into many algorithms over the course of this book, I want to drive home that machine learning models <em>need</em> data to learn. We can have the fanciest neural network on the best GPU cluster in the world, but without data, it’s all pointless. To drive this point home let’s see some machine learning in action.</p>
<p>We’ll start with a line. Nothing special, just the equation <code>f(x) = x + 1</code>.</p>
<div id="c4a0b951-9d1e-4856-aa10-4fe2d903bba4" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a>sns.set_theme(style<span class="op">=</span><span class="st">"darkgrid"</span>)</span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">def</span> f(x):</span>
<span id="cb1-7"><a href="#cb1-7"></a>    <span class="co">"""Function that applies `x + 1` to `x`."""</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>    <span class="cf">return</span> x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb1-9"><a href="#cb1-9"></a></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="kw">def</span> get_y(xs):</span>
<span id="cb1-11"><a href="#cb1-11"></a>    <span class="co">"""Return `y` for every `x` in the list `xs`."""</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    <span class="cf">return</span> <span class="bu">list</span>(<span class="bu">map</span>(f, xs))</span>
<span id="cb1-13"><a href="#cb1-13"></a></span>
<span id="cb1-14"><a href="#cb1-14"></a></span>
<span id="cb1-15"><a href="#cb1-15"></a>x <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>]</span>
<span id="cb1-16"><a href="#cb1-16"></a>y <span class="op">=</span> get_y(x)</span>
<span id="cb1-17"><a href="#cb1-17"></a>sns.lineplot(x<span class="op">=</span>x, y<span class="op">=</span>y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="data_files/figure-html/cell-2-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div class="page-columns page-full"><p>This line is the ground truth. It is real. But let’s imagine we don’t have the line. We just have a couple random points on the line.</p><div class="no-row-height column-margin column-container"><span class="margin-aside">I love <a href="https://seaborn.pydata.org/"><code>seaborn</code></a> for rapid data visualization. It can’t do everything perfectly, but it does the common things beautifully.</span></div></div>
<div id="7856c388-a970-4c9a-8501-0e22015f7517" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="im">import</span> random</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a>random.seed(<span class="dv">100392</span>)</span>
<span id="cb2-5"><a href="#cb2-5"></a></span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="kw">def</span> random_x(n):</span>
<span id="cb2-8"><a href="#cb2-8"></a>    <span class="co">"""Return `n` random values from -1 to 1."""</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="cf">return</span> [random.uniform(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb2-10"><a href="#cb2-10"></a></span>
<span id="cb2-11"><a href="#cb2-11"></a></span>
<span id="cb2-12"><a href="#cb2-12"></a>xs <span class="op">=</span> random_x(<span class="dv">2</span>)</span>
<span id="cb2-13"><a href="#cb2-13"></a>ys <span class="op">=</span> get_y(xs)</span>
<span id="cb2-14"><a href="#cb2-14"></a>sns.scatterplot(x<span class="op">=</span>xs, y<span class="op">=</span>ys)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="data_files/figure-html/cell-3-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Visually, we could draw a line from dot to dot and we’d get the same line in the previous plot. But we’re not interested in figuring out the line ourselves. We’re here to have machine learning do it for us. This is already integrated into <code>seaborn</code> so there’s not much code for us to write. The <a href="https://seaborn.pydata.org/generated/seaborn.regplot.html"><code>regplot</code></a> function will plot our data points and use machine learning to fit a line to those data points.</p>
<div id="28aacf5f-c69e-428f-9fdf-482b3e1ac88c" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>sns.regplot(x<span class="op">=</span>xs, y<span class="op">=</span>ys, truncate<span class="op">=</span><span class="va">False</span>, ci<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="data_files/figure-html/cell-4-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Will you look at that! The line was perfectly predicted based on the data points.</p>
<p>But real world data isn’t this simple or this <em>clean</em>. There’s usually some amount of noise in the data that can affect the quality of predictions. Noise is randomness introduced to the data. It can come from many places like imprecise measurements, mislabelling, or unaccounted variables to name a few.</p>
<p>Now let’s imagine we don’t have points on the line, but points close to the line. How will this change the predicted line?</p>
<div id="fc1c37b7-49af-4b13-819b-1b95eef6a831" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="co"># Add noise to the data points to simulate noisy data.</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">def</span> noisy_process(xs, noise):</span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="co">"""Return `f(x)` with noise."""</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>    <span class="cf">return</span> [</span>
<span id="cb4-5"><a href="#cb4-5"></a>        y <span class="op">+</span> random.uniform(<span class="op">-</span>noise, noise)</span>
<span id="cb4-6"><a href="#cb4-6"></a>        <span class="cf">for</span> x, y <span class="kw">in</span> <span class="bu">zip</span>(xs, get_y(xs))</span>
<span id="cb4-7"><a href="#cb4-7"></a>    ]</span>
<span id="cb4-8"><a href="#cb4-8"></a></span>
<span id="cb4-9"><a href="#cb4-9"></a></span>
<span id="cb4-10"><a href="#cb4-10"></a>ys_noisy <span class="op">=</span> noisy_process(xs, <span class="fl">0.25</span>)</span>
<span id="cb4-11"><a href="#cb4-11"></a></span>
<span id="cb4-12"><a href="#cb4-12"></a>ax <span class="op">=</span> sns.regplot(</span>
<span id="cb4-13"><a href="#cb4-13"></a>    x<span class="op">=</span>xs,</span>
<span id="cb4-14"><a href="#cb4-14"></a>    y<span class="op">=</span>ys,</span>
<span id="cb4-15"><a href="#cb4-15"></a>    truncate<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb4-16"><a href="#cb4-16"></a>    ci<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb4-17"><a href="#cb4-17"></a>    scatter_kws<span class="op">=</span>{<span class="st">"alpha"</span>: <span class="fl">0.5</span>},</span>
<span id="cb4-18"><a href="#cb4-18"></a>)</span>
<span id="cb4-19"><a href="#cb4-19"></a>sns.regplot(</span>
<span id="cb4-20"><a href="#cb4-20"></a>    x<span class="op">=</span>xs,</span>
<span id="cb4-21"><a href="#cb4-21"></a>    y<span class="op">=</span>ys_noisy,</span>
<span id="cb4-22"><a href="#cb4-22"></a>    truncate<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb4-23"><a href="#cb4-23"></a>    ci<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb4-24"><a href="#cb4-24"></a>    ax<span class="op">=</span>ax,</span>
<span id="cb4-25"><a href="#cb4-25"></a>    scatter_kws<span class="op">=</span>{<span class="st">"alpha"</span>: <span class="fl">0.5</span>},</span>
<span id="cb4-26"><a href="#cb4-26"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="data_files/figure-html/cell-5-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div class="page-columns page-full"><p>Hmm, that doesn’t look so bad. The predicted line in orange is pretty close to the real line in blue and has the same slope. But what if we just got lucky and the random noise happened to be low? Maybe we should run it a few more times to be sure.</p><div class="no-row-height column-margin column-container"><span class="margin-aside"><a href="https://pandas.pydata.org/docs/"><code>pandas</code></a> is another great library we’ll use over and over again. We’ll get to more on that later.</span></div></div>
<div id="9e6f27d3-159b-4a50-b4e0-27c01ec05c68" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="kw">def</span> simulate_n(n, n_points, noise):</span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span class="co">"""</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="co">    Return a `pd.DataFrame` with `n` separate simulations</span></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="co">    of `n_points`.</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="co">    """</span></span>
<span id="cb5-9"><a href="#cb5-9"></a>    data <span class="op">=</span> []</span>
<span id="cb5-10"><a href="#cb5-10"></a>    real_x <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>]</span>
<span id="cb5-11"><a href="#cb5-11"></a>    real_y <span class="op">=</span> get_y(real_x)</span>
<span id="cb5-12"><a href="#cb5-12"></a>    <span class="cf">for</span> x, y <span class="kw">in</span> <span class="bu">zip</span>(real_x, real_y):</span>
<span id="cb5-13"><a href="#cb5-13"></a>        data.append(</span>
<span id="cb5-14"><a href="#cb5-14"></a>            {</span>
<span id="cb5-15"><a href="#cb5-15"></a>                <span class="st">"x"</span>: x,</span>
<span id="cb5-16"><a href="#cb5-16"></a>                <span class="st">"y"</span>: y,</span>
<span id="cb5-17"><a href="#cb5-17"></a>                <span class="st">"simulation"</span>: <span class="st">"Ground Truth"</span>,</span>
<span id="cb5-18"><a href="#cb5-18"></a>                <span class="st">"noise"</span>: noise,</span>
<span id="cb5-19"><a href="#cb5-19"></a>            }</span>
<span id="cb5-20"><a href="#cb5-20"></a>        )</span>
<span id="cb5-21"><a href="#cb5-21"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb5-22"><a href="#cb5-22"></a>        xs <span class="op">=</span> random_x(n_points)</span>
<span id="cb5-23"><a href="#cb5-23"></a>        ys <span class="op">=</span> noisy_process(xs, noise)</span>
<span id="cb5-24"><a href="#cb5-24"></a>        <span class="cf">for</span> x, y <span class="kw">in</span> <span class="bu">zip</span>(xs, ys):</span>
<span id="cb5-25"><a href="#cb5-25"></a>            data.append(</span>
<span id="cb5-26"><a href="#cb5-26"></a>                {</span>
<span id="cb5-27"><a href="#cb5-27"></a>                    <span class="st">"x"</span>: x,</span>
<span id="cb5-28"><a href="#cb5-28"></a>                    <span class="st">"y"</span>: y,</span>
<span id="cb5-29"><a href="#cb5-29"></a>                    <span class="st">"simulation"</span>: i <span class="op">+</span> <span class="dv">1</span>,</span>
<span id="cb5-30"><a href="#cb5-30"></a>                    <span class="st">"noise"</span>: noise,</span>
<span id="cb5-31"><a href="#cb5-31"></a>                }</span>
<span id="cb5-32"><a href="#cb5-32"></a>            )</span>
<span id="cb5-33"><a href="#cb5-33"></a>    <span class="cf">return</span> pd.DataFrame(data)</span>
<span id="cb5-34"><a href="#cb5-34"></a></span>
<span id="cb5-35"><a href="#cb5-35"></a></span>
<span id="cb5-36"><a href="#cb5-36"></a>df <span class="op">=</span> simulate_n(<span class="dv">4</span>, <span class="dv">2</span>, <span class="fl">0.25</span>)</span>
<span id="cb5-37"><a href="#cb5-37"></a><span class="co"># `lmplot` is a fancier version of `regplot` that can handle</span></span>
<span id="cb5-38"><a href="#cb5-38"></a><span class="co"># multiple lines.</span></span>
<span id="cb5-39"><a href="#cb5-39"></a>sns.lmplot(</span>
<span id="cb5-40"><a href="#cb5-40"></a>    df,</span>
<span id="cb5-41"><a href="#cb5-41"></a>    x<span class="op">=</span><span class="st">"x"</span>,</span>
<span id="cb5-42"><a href="#cb5-42"></a>    y<span class="op">=</span><span class="st">"y"</span>,</span>
<span id="cb5-43"><a href="#cb5-43"></a>    ci<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb5-44"><a href="#cb5-44"></a>    hue<span class="op">=</span><span class="st">"simulation"</span>,</span>
<span id="cb5-45"><a href="#cb5-45"></a>    truncate<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb5-46"><a href="#cb5-46"></a>    scatter_kws<span class="op">=</span>{<span class="st">"alpha"</span>: <span class="fl">0.5</span>},</span>
<span id="cb5-47"><a href="#cb5-47"></a>    facet_kws<span class="op">=</span>{<span class="st">"xlim"</span>: (<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>), <span class="st">"ylim"</span>: (<span class="dv">0</span>, <span class="dv">2</span>)},</span>
<span id="cb5-48"><a href="#cb5-48"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="data_files/figure-html/cell-6-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Most of these look pretty close to the blue line, the ground truth, but what’s going on with simulation 4? The noise confused the machine learning model. It only has two points to work with and given two points it can figure out a line that perfectly lies on those two points. These two points imperfectly represent the real line and so the machine learned the line of this imperfect representation. And it gets worse with more noise.</p>
<div id="accd66e7-c505-49b1-a7ed-f9754905cf05" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>df <span class="op">=</span> pd.concat(</span>
<span id="cb6-2"><a href="#cb6-2"></a>    [simulate_n(<span class="dv">4</span>, <span class="dv">2</span>, noise) <span class="cf">for</span> noise <span class="kw">in</span> [<span class="fl">0.25</span>, <span class="fl">0.5</span>, <span class="dv">1</span>]]</span>
<span id="cb6-3"><a href="#cb6-3"></a>)</span>
<span id="cb6-4"><a href="#cb6-4"></a>sns.lmplot(</span>
<span id="cb6-5"><a href="#cb6-5"></a>    df,</span>
<span id="cb6-6"><a href="#cb6-6"></a>    x<span class="op">=</span><span class="st">"x"</span>,</span>
<span id="cb6-7"><a href="#cb6-7"></a>    y<span class="op">=</span><span class="st">"y"</span>,</span>
<span id="cb6-8"><a href="#cb6-8"></a>    ci<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb6-9"><a href="#cb6-9"></a>    hue<span class="op">=</span><span class="st">"simulation"</span>,</span>
<span id="cb6-10"><a href="#cb6-10"></a>    truncate<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb6-11"><a href="#cb6-11"></a>    col<span class="op">=</span><span class="st">"noise"</span>,</span>
<span id="cb6-12"><a href="#cb6-12"></a>    scatter_kws<span class="op">=</span>{<span class="st">"alpha"</span>: <span class="fl">0.5</span>},</span>
<span id="cb6-13"><a href="#cb6-13"></a>    facet_kws<span class="op">=</span>{<span class="st">"xlim"</span>: (<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>), <span class="st">"ylim"</span>: (<span class="dv">0</span>, <span class="dv">2</span>)},</span>
<span id="cb6-14"><a href="#cb6-14"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="data_files/figure-html/cell-7-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Yup, that’s a mess. At <code>noise = 0.5</code> the lines start to drift from the real line and at <code>noise = 1.0</code> most of them aren’t even close. But all is not lost, there is a way to learn from noisy data. Use more of it! Let’s try a hundred points per simulation.</p>
<div id="1d022a47-28ff-443b-a955-f6a6875f58d9" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a>df <span class="op">=</span> pd.concat(</span>
<span id="cb7-2"><a href="#cb7-2"></a>    [simulate_n(<span class="dv">4</span>, <span class="dv">100</span>, noise) <span class="cf">for</span> noise <span class="kw">in</span> [<span class="fl">0.25</span>, <span class="fl">0.5</span>, <span class="dv">1</span>]]</span>
<span id="cb7-3"><a href="#cb7-3"></a>)</span>
<span id="cb7-4"><a href="#cb7-4"></a>sns.lmplot(</span>
<span id="cb7-5"><a href="#cb7-5"></a>    df,</span>
<span id="cb7-6"><a href="#cb7-6"></a>    x<span class="op">=</span><span class="st">"x"</span>,</span>
<span id="cb7-7"><a href="#cb7-7"></a>    y<span class="op">=</span><span class="st">"y"</span>,</span>
<span id="cb7-8"><a href="#cb7-8"></a>    ci<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb7-9"><a href="#cb7-9"></a>    hue<span class="op">=</span><span class="st">"simulation"</span>,</span>
<span id="cb7-10"><a href="#cb7-10"></a>    truncate<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb7-11"><a href="#cb7-11"></a>    col<span class="op">=</span><span class="st">"noise"</span>,</span>
<span id="cb7-12"><a href="#cb7-12"></a>    scatter_kws<span class="op">=</span>{<span class="st">"alpha"</span>: <span class="fl">0.5</span>},</span>
<span id="cb7-13"><a href="#cb7-13"></a>    facet_kws<span class="op">=</span>{<span class="st">"xlim"</span>: (<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>), <span class="st">"ylim"</span>: (<span class="dv">0</span>, <span class="dv">2</span>)},</span>
<span id="cb7-14"><a href="#cb7-14"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="data_files/figure-html/cell-8-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>That’s night and day compared to two data points. Even when <code>noise = 1.0</code> the machine learning model does a good job of finding the line. This is because there’s more information to learn from and the machine learning model can separate the noise and zero in on the truth.</p>
<p>The lesson here is data quality is important, but so is data <em>quantity</em>. Sometimes the answer is a better machine learning model, but that’s not always true, you might just need more data. On the other hand, if you can’t get enough data, you may need better <em>quality</em> data. If you’re stuck with a small amount of low quality data, then machine learning may not be the answer to your problem.</p>
</section>
<section id="the-dataset" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="the-dataset"><span class="header-section-number">1.2</span> The dataset</h2>
<p>Our models will be using datasets of movie reviews from IMDB <span class="citation" data-cites="maas-EtAl:2011:ACL-HLT2011">(<a href="../../references.html#ref-maas-EtAl:2011:ACL-HLT2011" role="doc-biblioref">Maas et al. 2011</a>)</span>. The original datasets can be found at <a href="https://ai.stanford.edu/~amaas/data/sentiment">https://ai.stanford.edu/~amaas/data/sentiment</a>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>One of the most important chapters in this book is about cleaning data. It’s a bonus chapter at the end. It walks through the steps and analysis I performed to clean and prepare the dataset for this book. At this point it’s not important. The focus should be on building models as fast as possible and iterating on them. By the end of this book, you should feel comfortable with machine learning, at which point understanding where data comes from and how it’s prepared becomes useful. After all we want to apply te things learned here to the real world, and that starts with real world data.</p>
<p>It is still a bonus chapter and not required for understanding machine learning, but I found some suprising things when I cleaned this dataset. If you make it to the end, you really should read it.</p>
</div>
</div>
<p>I’ve taken the liberty of further cleaning the data and making it accessible through a Python API so we can get right to work on machine learning and NLP.</p>
<p>This book provides a conda environment file (see the <a href="intro.qmd#what-this-book-is">introduction</a>) with everything you need to run the code. If you want to access the dataset without setting up the conda environment, you can get access to it through <code>pip</code>. If you’re just following along through the book website then there’s nothing you need to do.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> pip install git+https://github.com/spenceforce/NLP-Simple-to-Spectacular</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s get a feel for the datasets before we move on to machine learning. There are two movie review datasets available. One for classification and the other for unsupervised learning.</p>
</section>
<section id="classification-dataset" class="level2 page-columns page-full" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="classification-dataset"><span class="header-section-number">1.3</span> Classification dataset</h2>
<p>This dataset contains movie reviews and labels indicating if the review is positive (label 1) or negative (label 0). It is intended for benchmarking sentiment classification tasks. Sentiment classification is about predicting the feeling a text conveys. Like emotions such as happy, sad, or angry. In this case it’s predicting whether a review says if a movie is good or bad.</p>
<p>This dataset is split into a set for training and a set for testing. We can access both the train and test sets with <code>get_train_test_data</code>, which returns a <code>DataFrame</code> object for each set. The <code>DataFrame</code> class is a staple of <a href="https://pandas.pydata.org/docs/"><code>pandas</code></a>. Dataframes are tables and they are not unique to <code>pandas</code>, but <code>pandas</code> is a de facto Python library for working with dataframes. You can think of dataframes as the programmatic version of an excel spreadsheet.</p>
<div id="026e61c9-afc6-4ddf-880a-b635d005c406" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="im">from</span> nlpbook <span class="im">import</span> get_train_test_data</span>
<span id="cb9-2"><a href="#cb9-2"></a>train_df, test_df <span class="op">=</span> get_train_test_data()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>train_df</code> and <code>test_df</code> have the same format, so we’ll just inspect <code>train_df</code>. We can see how many rows are in the dataframe and information about the columns with <code>DataFrame.info()</code>.</p>
<div id="9b853f6c-6d5a-48a4-8d23-a608224cb0f1" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a>train_df.info()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;
Index: 24904 entries, 0 to 12499
Data columns (total 5 columns):
 #   Column    Non-Null Count  Dtype 
---  ------    --------------  ----- 
 0   id        24904 non-null  int64 
 1   movie_id  24904 non-null  object
 2   rating    24904 non-null  int64 
 3   review    24904 non-null  object
 4   label     24904 non-null  int64 
dtypes: int64(3), object(2)
memory usage: 1.1+ MB</code></pre>
</div>
</div>
<div class="page-columns page-full"><p><code>DataFrame.info()</code> says there are 24,904 rows. There are five columns, three of which have type <code>int64</code> and two with type <code>object</code>; the <code>object</code> types are strings in our dataframe.</p><div class="no-row-height column-margin column-container"><span class="margin-aside"><code>pandas</code> assigns the type <code>object</code> to non-numeric values.</span></div></div>
<p>Each row is for one review. A brief rundown of what the columns are:</p>
<ul>
<li><code>id</code>: The review ID.</li>
<li><code>movie_id</code>: The movie ID.</li>
<li><code>rating</code>: A score from 1-10 that the reviewer gave the movie.</li>
<li><code>review</code>: This is the review. Pretty self-explanatory.</li>
<li><code>label</code>: A 0 or 1 value indicating if the review is negative or positive, respectively.</li>
</ul>
<p>The columns we’re interested in are <code>review</code>, <code>label</code>, and to a lesser extend, <code>rating</code>. <code>review</code> will be the input to all models as this is the natural language we are trying to process. <code>label</code> and <code>rating</code> are what we’re trying to predict! We will mainly be predicting <code>label</code>, but we will also use <code>rating</code> to show how to scale binary classification (predicting two labels) to multiple labels (predicting three or more labels).</p>
<p>Let’s inspect a few reviews with <code>DataFrame.head()</code>.</p>
<div id="d8dc74ce-2047-44a9-b67b-2a264d6adcf5" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a>train_df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">id</th>
<th data-quarto-table-cell-role="th">movie_id</th>
<th data-quarto-table-cell-role="th">rating</th>
<th data-quarto-table-cell-role="th">review</th>
<th data-quarto-table-cell-role="th">label</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>7275</td>
<td>tt0082799</td>
<td>1</td>
<td>"National Lampoon Goes to the Movies" (1981) i...</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1438</td>
<td>tt0397501</td>
<td>4</td>
<td>Well! What can one say? Firstly, this adaptati...</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>9137</td>
<td>tt0364986</td>
<td>1</td>
<td>What can I say, this is a piece of brilliant f...</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>173</td>
<td>tt0283974</td>
<td>3</td>
<td>A decent sequel, but does not pack the punch o...</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>8290</td>
<td>tt0314630</td>
<td>2</td>
<td>Alan Rudolph is a so-so director, without that...</td>
<td>0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>The <code>review</code> column looks like natural language and the <code>label</code> and <code>rating</code> columns have numeric values just like <code>DataFrame.info()</code> said.</p>
<p>We can also see how this dataset is split by label.</p>
<div id="e52f49a5-2e03-4810-b221-e1c46d1fbf2a" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a>train_df.value_counts(<span class="st">"label"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="11">
<pre><code>label
1    12472
0    12432
Name: count, dtype: int64</code></pre>
</div>
</div>
<p>There are 12,472 positive labels and 12,432 negative labels. That’s almost a 50/50 split.</p>
</section>
<section id="unsupervised-dataset" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="unsupervised-dataset"><span class="header-section-number">1.4</span> Unsupervised dataset</h2>
<p>The train/test sets above have labels, 0 or 1, which allows them to be used in a <em>supervised</em> learning fashion. In supervised learning we have real outputs, the review labels in this case, to compare to our machine learning model outputs. We can supervise the models learning by comparing it’s outputs to the labels and let the model know how it’s doing.</p>
<p>Unsupervised learning is just input data. There’s no label to use as a comparator. Instead the model must learn from the data without knowing whether it is right or wrong. This kind of learning is less about predicting a specific property and more about learning general properties of the data.</p>
<p>This dataset is available through <code>get_unsup_data</code>. Let’s inspect it with <code>DataFrame.info()</code>.</p>
<div id="20a4a512-c06c-4c2a-8bfb-37e5013e0d11" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a><span class="im">from</span> nlpbook <span class="im">import</span> get_unsup_data</span>
<span id="cb15-2"><a href="#cb15-2"></a>unsup_df <span class="op">=</span> get_unsup_data()</span>
<span id="cb15-3"><a href="#cb15-3"></a>unsup_df.info()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;
Index: 49507 entries, 0 to 49999
Data columns (total 3 columns):
 #   Column    Non-Null Count  Dtype 
---  ------    --------------  ----- 
 0   id        49507 non-null  int64 
 1   movie_id  49507 non-null  object
 2   review    49507 non-null  object
dtypes: int64(1), object(2)
memory usage: 1.5+ MB</code></pre>
</div>
</div>
<p>As you can see, there is no <code>label</code> or <code>rating</code> columns. It’s just reviews and nothing else.</p>
</section>
<section id="conclusion" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="conclusion"><span class="header-section-number">1.5</span> Conclusion</h2>
<p>In this chapter we made our first machine learning model which predicted the equation <code>f(x) = x + 1</code>. We saw the tradeoff between data quality and quantity. Then we inspected the datasets we will use throughout this book.</p>
<p>The next chapter will focus on building our first model from scratch.</p>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-maas-EtAl:2011:ACL-HLT2011" class="csl-entry" role="listitem">
Maas, Andrew L., Raymond E. Daly, Peter T. Pham, Dan Huang, Andrew Y. Ng, and Christopher Potts. 2011. <span>“Learning Word Vectors for Sentiment Analysis.”</span> In <em>Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies</em>, 142–50. Portland, Oregon, USA: Association for Computational Linguistics. <a href="http://www.aclweb.org/anthology/P11-1015">http://www.aclweb.org/anthology/P11-1015</a>.
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../intro.html" class="pagination-link" aria-label="Introduction">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Introduction</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../chapter/02_baseline/baseline_classifier.html" class="pagination-link" aria-label="Baseline: gotta start somewhere">
        <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Baseline: gotta start somewhere</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>