<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>4&nbsp; OneR, TwoR, RedR, BlueR: Inputs matter – NLP: From Simple to Spectacular</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../chapter/bonus/cleaning_data/cleaning_data.html" rel="next">
<link href="../../chapter/03_oner/oner.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-cd7de1037569933fbb609f06423bd096.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


</head>

<body class="nav-sidebar floating slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../chapter/04_oner/oner.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">OneR, TwoR, RedR, BlueR: Inputs matter</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">NLP: From Simple to Spectacular</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapter/01_data/data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Machine learning needs data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapter/02_baseline/baseline_classifier.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Baseline: gotta start somewhere</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapter/03_oner/oner.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">OneR</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapter/04_oner/oner.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">OneR, TwoR, RedR, BlueR: Inputs matter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapter/bonus/cleaning_data/cleaning_data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Bonus: cleaning data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapter/bonus/quality_vs_quantity/quality_vs_quantity.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Bonus: quality vs.&nbsp;quantity</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#feature-extraction" id="toc-feature-extraction" class="nav-link active" data-scroll-target="#feature-extraction"><span class="header-section-number">4.1</span> Feature extraction</a>
  <ul class="collapse">
  <li><a href="#bag-of-characters" id="toc-bag-of-characters" class="nav-link" data-scroll-target="#bag-of-characters"><span class="header-section-number">4.1.1</span> Bag of characters</a></li>
  </ul></li>
  <li><a href="#oner-revisited" id="toc-oner-revisited" class="nav-link" data-scroll-target="#oner-revisited"><span class="header-section-number">4.2</span> OneR revisited</a></li>
  <li><a href="#machine-learning-is-an-end-to-end-process" id="toc-machine-learning-is-an-end-to-end-process" class="nav-link" data-scroll-target="#machine-learning-is-an-end-to-end-process"><span class="header-section-number">4.3</span> Machine learning is an end to end process</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">OneR, TwoR, RedR, BlueR: Inputs matter</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><a href="../../chapter/03_oner/oner.html">Last chapter</a> we implemented the OneR <span class="citation" data-cites="Holte1993">(<a href="../../references.html#ref-Holte1993" role="doc-biblioref">Holte 1993</a>)</span> algorithm. In this chapter we’ll improve the model without improving the model. Sounds strange, but bear with me. This chapter is all about changing the input to the model.</p>
<p>Right now we just pass in the review as input. It’s a string and every review is unique. The review is treated as a category where each unique review is it’s own category. Before training, each unique review is assigned a number to represent it.</p>
<p>With this setup, the only way to compare two reviews is to see if they are the same review or not. But two pieces of text contain much richer information that can be used to compare them. Letters make up words, words make up sentences, sentences make up paragraphs, and so on. Language also has syntax and semantics. As machine learning practitioners we actually don’t care about syntax and semantics. We expect our models will learn the concepts they need as they train on the target task. We do care about how the text is represented as this is what our models learn from. Our model currently learns from a single number that represents a review. Let’s change that.</p>
<section id="feature-extraction" class="level2 page-columns page-full" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="feature-extraction"><span class="header-section-number">4.1</span> Feature extraction</h2>
<p>Feature extraction is a way to convert data into a format that is useable by machine learning models. Data that is numeric, like scientific measurements, are machine learning friendly by default, but text and image data is not. These types of data need to be converted to numbers in a way that preserves their information. Last chapter we converted our text data to numbers, but we didn’t preserve any of the information in the reviews and ended up with a model that performed the same as the baseline.</p>
<p>We’ll try again, but while preserving some of the information in the text. As always, let’s start simple.</p>
<section id="bag-of-characters" class="level3 page-columns page-full" data-number="4.1.1">
<h3 data-number="4.1.1" class="anchored" data-anchor-id="bag-of-characters"><span class="header-section-number">4.1.1</span> Bag of characters</h3>
<div class="page-columns page-full"><p>We have reviews. These are just sentences, which are just words, which are just characters. So reviews are characters. We can count the number of each character in a review and represent the review as character counts. This is representation is called a bag of characters and it can be extended to words, sentences, or whatever you want really. And of course <code>sklearn</code> has a way to do this.</p><div class="no-row-height column-margin column-container"><span class="margin-aside"><code>CountVectotrizer</code> returns a <a href="https://docs.scipy.org/doc/scipy/reference/sparse.html">sparse matrix</a> which are memory efficient for matrices that contain mostly 0s.</span></div></div>
<div id="e8a9c5a2-74ac-47ce-98b2-9db658890d47" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">from</span> nlpbook <span class="im">import</span> get_train_test_data</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">from</span> sklearn.feature_extraction.text <span class="im">import</span> CountVectorizer</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a>train_df, test_df <span class="op">=</span> get_train_test_data()</span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="co"># Create the bag of characters feature extraction transformer.</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co"># The `CountVectorizer` class performs bags input text. We set</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="co"># `analyzer="char"` so that `CountVectorizer` counts characters</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="co"># instead of words and `lowercase=False` to prevent upper case</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="co"># letters from being converted to lowercase.</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>vectorizer <span class="op">=</span> CountVectorizer(analyzer<span class="op">=</span><span class="st">"char"</span>, lowercase<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb1-12"><a href="#cb1-12"></a></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="co"># Fit the bag of characters transformer on our reviews.</span></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="co"># Notice we do not pass a matrix into the fit method, but an array.</span></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="co"># Feature extraction should be performed on a per column basis so</span></span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="co"># we need to pass in the column we want feature extraction performed</span></span>
<span id="cb1-17"><a href="#cb1-17"></a><span class="co"># on.</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>vectorizer.fit(train_df[<span class="st">"review"</span>])</span>
<span id="cb1-19"><a href="#cb1-19"></a></span>
<span id="cb1-20"><a href="#cb1-20"></a><span class="co"># Transform the first row to a bag of characters.</span></span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="co"># Convert the sparse matrix to a numpy array to see the counts.</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>vectorizer.transform(train_df[<span class="st">"review"</span>].head(<span class="dv">1</span>)).toarray()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>array([[  0,   0,   0, 275,   0,   6,   0,   0,   0,   1,   5,   1,   1,
          0,   0,  25,   4,  16,   8,   0,   2,   0,   0,   0,   0,   0,
          0,   1,   2,   0,   0,   8,   0,   8,   0,   0,   2,   5,   0,
          1,   0,   0,   3,   2,   3,   0,   0,   3,   5,   2,   1,   1,
          0,   2,   1,   5,   1,   0,   3,   0,   0,   0,   0,   0,   0,
          0,   0,   0,  99,  24,  23,  50, 166,  31,  21,  64,  84,   1,
          5,  61,  27,  89,  92,  30,   1,  94,  90, 122,  29,  13,  17,
          0,  35,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
          0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
          0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
          0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
          0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
          0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
          0,   0,   0,   0,   0,   0,   0,   0,   0]])</code></pre>
</div>
</div>
<p>We can check what character each array element is counting with the <code>vocabulary_</code> dict.</p>
<div id="a1892adc-36f1-448c-98e8-cfbba1393ade" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="bu">list</span>(vectorizer.vocabulary_.items())[:<span class="dv">5</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>[('"', 5), ('N', 49), ('a', 68), ('t', 87), ('i', 76)]</code></pre>
</div>
</div>
<p>So index 5 of the above array is the counts for the character <code>"</code> and index 49 is the counts for <code>N</code>.</p>
</section>
</section>
<section id="oner-revisited" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="oner-revisited"><span class="header-section-number">4.2</span> OneR revisited</h2>
<p>Now we can just pass this as input to our OneR model right? Not quite, our model isn’t capable of handling this input yet. Here’s the implementation from last chapter.</p>
<div id="55fc1448-812f-40bd-8ba8-750aa07e65fe" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="im">from</span> sklearn.base <span class="im">import</span> BaseEstimator, ClassifierMixin</span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="im">from</span> sklearn.dummy <span class="im">import</span> DummyClassifier</span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="im">from</span> sklearn.utils.validation <span class="im">import</span> validate_data</span>
<span id="cb5-5"><a href="#cb5-5"></a></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="kw">class</span> OneR(ClassifierMixin, BaseEstimator):</span>
<span id="cb5-7"><a href="#cb5-7"></a>    <span class="kw">def</span> fit(<span class="va">self</span>, X, y):</span>
<span id="cb5-8"><a href="#cb5-8"></a>        <span class="co">"""Find the most predictive rule."""</span></span>
<span id="cb5-9"><a href="#cb5-9"></a>        <span class="co"># Sanity check on `X` and `y`.</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>        X, y <span class="op">=</span> validate_data(<span class="va">self</span>, X, y)</span>
<span id="cb5-11"><a href="#cb5-11"></a>        predictors <span class="op">=</span> {}</span>
<span id="cb5-12"><a href="#cb5-12"></a>        <span class="co"># Get the unique categories from the first column.</span></span>
<span id="cb5-13"><a href="#cb5-13"></a>        categories <span class="op">=</span> np.unique(X[:, <span class="dv">0</span>])</span>
<span id="cb5-14"><a href="#cb5-14"></a>        <span class="cf">for</span> category <span class="kw">in</span> categories:</span>
<span id="cb5-15"><a href="#cb5-15"></a>            <span class="co"># Create a conditional array where each index</span></span>
<span id="cb5-16"><a href="#cb5-16"></a>            <span class="co"># is a boolean indicating if that index in the</span></span>
<span id="cb5-17"><a href="#cb5-17"></a>            <span class="co"># first column of `X` is the category we're iterating</span></span>
<span id="cb5-18"><a href="#cb5-18"></a>            <span class="co"># over.</span></span>
<span id="cb5-19"><a href="#cb5-19"></a>            is_category <span class="op">=</span> X[:, <span class="dv">0</span>] <span class="op">==</span> category</span>
<span id="cb5-20"><a href="#cb5-20"></a>            <span class="co"># Grab all data points and labels in this category.</span></span>
<span id="cb5-21"><a href="#cb5-21"></a>            _X <span class="op">=</span> X[is_category]</span>
<span id="cb5-22"><a href="#cb5-22"></a>            _y <span class="op">=</span> y[is_category]</span>
<span id="cb5-23"><a href="#cb5-23"></a>            <span class="co"># Train a baseline classifier on the category.</span></span>
<span id="cb5-24"><a href="#cb5-24"></a>            predictors[category] <span class="op">=</span> DummyClassifier().fit(_X, _y)</span>
<span id="cb5-25"><a href="#cb5-25"></a>        <span class="va">self</span>.predictors_ <span class="op">=</span> predictors</span>
<span id="cb5-26"><a href="#cb5-26"></a>        <span class="co"># Create a fallback predictor for unknown categories.</span></span>
<span id="cb5-27"><a href="#cb5-27"></a>        <span class="va">self</span>.unknown_predictor_ <span class="op">=</span> DummyClassifier().fit(X, y)</span>
<span id="cb5-28"><a href="#cb5-28"></a>        <span class="cf">return</span> <span class="va">self</span></span>
<span id="cb5-29"><a href="#cb5-29"></a></span>
<span id="cb5-30"><a href="#cb5-30"></a>    <span class="kw">def</span> predict(<span class="va">self</span>, X):</span>
<span id="cb5-31"><a href="#cb5-31"></a>        <span class="co">"""Predict the labels for inputs `X`."""</span></span>
<span id="cb5-32"><a href="#cb5-32"></a>        <span class="co"># Sanity check on `X`.</span></span>
<span id="cb5-33"><a href="#cb5-33"></a>        <span class="co"># `reset` should be `True` in `fit` and `False` everywhere else.</span></span>
<span id="cb5-34"><a href="#cb5-34"></a>        X <span class="op">=</span> validate_data(<span class="va">self</span>, X, reset<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb5-35"><a href="#cb5-35"></a>        <span class="co"># Create an empty array that will hold the predictions.</span></span>
<span id="cb5-36"><a href="#cb5-36"></a>        rv <span class="op">=</span> np.zeros(X.shape[<span class="dv">0</span>])</span>
<span id="cb5-37"><a href="#cb5-37"></a>        <span class="co"># Get the unique categories from the first column.</span></span>
<span id="cb5-38"><a href="#cb5-38"></a>        categories <span class="op">=</span> np.unique(X[:, <span class="dv">0</span>])</span>
<span id="cb5-39"><a href="#cb5-39"></a>        <span class="cf">for</span> category <span class="kw">in</span> categories:</span>
<span id="cb5-40"><a href="#cb5-40"></a>            <span class="co"># Create a conditional array where each index</span></span>
<span id="cb5-41"><a href="#cb5-41"></a>            <span class="co"># is a boolean indicating if that index in the</span></span>
<span id="cb5-42"><a href="#cb5-42"></a>            <span class="co"># first column of `X` is the category we're iterating</span></span>
<span id="cb5-43"><a href="#cb5-43"></a>            <span class="co"># over.</span></span>
<span id="cb5-44"><a href="#cb5-44"></a>            is_category <span class="op">=</span> X[:, <span class="dv">0</span>] <span class="op">==</span> category</span>
<span id="cb5-45"><a href="#cb5-45"></a>            <span class="co"># Grab all data points in this category.</span></span>
<span id="cb5-46"><a href="#cb5-46"></a>            _X <span class="op">=</span> X[is_category]</span>
<span id="cb5-47"><a href="#cb5-47"></a>            <span class="co"># Predict the label for all datapoints in `_X`.</span></span>
<span id="cb5-48"><a href="#cb5-48"></a>            <span class="cf">try</span>:</span>
<span id="cb5-49"><a href="#cb5-49"></a>                predictions <span class="op">=</span> <span class="va">self</span>.predictors_[category].predict(_X)</span>
<span id="cb5-50"><a href="#cb5-50"></a>            <span class="cf">except</span> <span class="pp">KeyError</span>:</span>
<span id="cb5-51"><a href="#cb5-51"></a>                <span class="co"># Fallback to the predictor for unknown categories.</span></span>
<span id="cb5-52"><a href="#cb5-52"></a>                predictions <span class="op">=</span> <span class="va">self</span>.unknown_predictor_.predict(_X)</span>
<span id="cb5-53"><a href="#cb5-53"></a>            <span class="co"># Assign the prediction for this category to</span></span>
<span id="cb5-54"><a href="#cb5-54"></a>            <span class="co"># the corresponding indices in `rv`.</span></span>
<span id="cb5-55"><a href="#cb5-55"></a>            rv[is_category] <span class="op">=</span> predictions</span>
<span id="cb5-56"><a href="#cb5-56"></a>        <span class="cf">return</span> rv</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Notice the model only looks at the first column. If we use it now it will use the counts in the first column of our bag of characters matrix for training and prediction which isn’t what we want.</p>
<p>It turns out I lied about the OneR algorithm last chapter. I said the algorithm works by predicting the most frequent label for each category, but in reality it only does this for <em>one feature</em>, hence the name OneR which stands for One Rule. The model finds the feature whose categories are most predictive of the training data, then predicts labels based on just that feature. When we first implemented this model we only had one feature so it didn’t matter, but now we have many, so we need to tweak the implementation to find the best feature when given any number of features.</p>
<div id="977b9412-fdfc-4f02-8dce-4e33d5f8bcc0" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="im">import</span> scipy.sparse</span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="co"># Rename the `OneR` class to `Rule`.</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>Rule <span class="op">=</span> OneR</span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="co"># Create a new `OneR` class which finds the best `Rule` in the</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="co"># dataset.</span></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="kw">class</span> OneR(ClassifierMixin, BaseEstimator):</span>
<span id="cb6-9"><a href="#cb6-9"></a>    <span class="kw">def</span> fit(<span class="va">self</span>, X, y):</span>
<span id="cb6-10"><a href="#cb6-10"></a>        <span class="co">"""Find the best rule in the dataset."""</span></span>
<span id="cb6-11"><a href="#cb6-11"></a>        <span class="co"># Sanity check on `X` and `y`.</span></span>
<span id="cb6-12"><a href="#cb6-12"></a>        X, y <span class="op">=</span> validate_data(<span class="va">self</span>, X, y, accept_sparse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb6-13"><a href="#cb6-13"></a></span>
<span id="cb6-14"><a href="#cb6-14"></a>        col_idx <span class="op">=</span> score <span class="op">=</span> rule <span class="op">=</span> <span class="va">None</span></span>
<span id="cb6-15"><a href="#cb6-15"></a>        <span class="co"># Iterate over the indices for each column in X.</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(X.shape[<span class="dv">1</span>]):</span>
<span id="cb6-17"><a href="#cb6-17"></a>            <span class="co"># Create a new matrix containing just the ith column.</span></span>
<span id="cb6-18"><a href="#cb6-18"></a>            _X <span class="op">=</span> X[:, [i]]</span>
<span id="cb6-19"><a href="#cb6-19"></a>            <span class="co"># Convert sparse matrix to `numpy` array.</span></span>
<span id="cb6-20"><a href="#cb6-20"></a>            <span class="co"># `Rule` works on numpy arrays, so we should use consistent</span></span>
<span id="cb6-21"><a href="#cb6-21"></a>            <span class="co"># array types.</span></span>
<span id="cb6-22"><a href="#cb6-22"></a>            <span class="cf">if</span> scipy.sparse.issparse(_X):</span>
<span id="cb6-23"><a href="#cb6-23"></a>                _X <span class="op">=</span> _X.toarray()</span>
<span id="cb6-24"><a href="#cb6-24"></a></span>
<span id="cb6-25"><a href="#cb6-25"></a>            <span class="co"># Create a rule for the ith column.</span></span>
<span id="cb6-26"><a href="#cb6-26"></a>            rule_i <span class="op">=</span> Rule().fit(_X, y)</span>
<span id="cb6-27"><a href="#cb6-27"></a>            <span class="co"># Score the ith columns accuracy.</span></span>
<span id="cb6-28"><a href="#cb6-28"></a>            score_i <span class="op">=</span> rule_i.score(_X, y)</span>
<span id="cb6-29"><a href="#cb6-29"></a></span>
<span id="cb6-30"><a href="#cb6-30"></a>            <span class="co"># Keep the rule for the ith column if it has the highest</span></span>
<span id="cb6-31"><a href="#cb6-31"></a>            <span class="co"># accuracy so far.</span></span>
<span id="cb6-32"><a href="#cb6-32"></a>            <span class="cf">if</span> score <span class="kw">is</span> <span class="va">None</span> <span class="kw">or</span> score_i <span class="op">&gt;</span> score:</span>
<span id="cb6-33"><a href="#cb6-33"></a>                rule <span class="op">=</span> rule_i</span>
<span id="cb6-34"><a href="#cb6-34"></a>                score <span class="op">=</span> score_i</span>
<span id="cb6-35"><a href="#cb6-35"></a>                col_idx <span class="op">=</span> i</span>
<span id="cb6-36"><a href="#cb6-36"></a></span>
<span id="cb6-37"><a href="#cb6-37"></a>        <span class="va">self</span>.rule_ <span class="op">=</span> rule</span>
<span id="cb6-38"><a href="#cb6-38"></a>        <span class="va">self</span>.i_ <span class="op">=</span> col_idx</span>
<span id="cb6-39"><a href="#cb6-39"></a>        <span class="cf">return</span> <span class="va">self</span></span>
<span id="cb6-40"><a href="#cb6-40"></a></span>
<span id="cb6-41"><a href="#cb6-41"></a>    <span class="kw">def</span> predict(<span class="va">self</span>, X):</span>
<span id="cb6-42"><a href="#cb6-42"></a>        <span class="co">"""Predict the labels for inputs `X`."""</span></span>
<span id="cb6-43"><a href="#cb6-43"></a>        <span class="co"># Sanity check on `X`.</span></span>
<span id="cb6-44"><a href="#cb6-44"></a>        X <span class="op">=</span> validate_data(<span class="va">self</span>, X, reset<span class="op">=</span><span class="va">False</span>, accept_sparse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb6-45"><a href="#cb6-45"></a>        _X <span class="op">=</span> X[:, [<span class="va">self</span>.i_]]</span>
<span id="cb6-46"><a href="#cb6-46"></a>        <span class="co"># Convert sparse matrix to `numpy` array.</span></span>
<span id="cb6-47"><a href="#cb6-47"></a>        <span class="co"># `Rule` works on numpy arrays, so we should use consistent</span></span>
<span id="cb6-48"><a href="#cb6-48"></a>        <span class="co"># array types.</span></span>
<span id="cb6-49"><a href="#cb6-49"></a>        <span class="cf">if</span> scipy.sparse.issparse(_X):</span>
<span id="cb6-50"><a href="#cb6-50"></a>            _X <span class="op">=</span> _X.toarray()</span>
<span id="cb6-51"><a href="#cb6-51"></a></span>
<span id="cb6-52"><a href="#cb6-52"></a>        <span class="co"># Return predictions for the rule.</span></span>
<span id="cb6-53"><a href="#cb6-53"></a>        <span class="cf">return</span> <span class="va">self</span>.rule_.predict(_X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And now we can train the model![<a href="https://scikit-learn.org/stable/modules/generated/sklearn.compose.ColumnTransformer.html"><code>ColumnTransformer</code></a> is a handy utility for applying transforms to specific columns of a dataframe.]</p>
<div id="471abf36-f1a1-477c-a736-90b4a65db906" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="im">from</span> sklearn.compose <span class="im">import</span> ColumnTransformer</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> Pipeline</span>
<span id="cb7-3"><a href="#cb7-3"></a></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="co"># Grab `X` and `y`.</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>features <span class="op">=</span> [<span class="st">"review"</span>]</span>
<span id="cb7-6"><a href="#cb7-6"></a>labels <span class="op">=</span> <span class="st">"label"</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>X, y <span class="op">=</span> train_df[features], train_df[labels]</span>
<span id="cb7-8"><a href="#cb7-8"></a></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="co"># Create the bag of characters transform.</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>bag_of_chars <span class="op">=</span> CountVectorizer(analyzer<span class="op">=</span><span class="st">"char"</span>, lowercase<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="co"># Wrap the bag of characters transform in a `ColumnTransformer`.</span></span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="co"># This class lets us perform transforms on specific columns of a</span></span>
<span id="cb7-13"><a href="#cb7-13"></a><span class="co"># `DataFrame` instead of on the entire `DataFrame`. This allows</span></span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="co"># us to use `CountVectorizer` on just the "review" column.</span></span>
<span id="cb7-15"><a href="#cb7-15"></a><span class="co"># Check the docs link in the margin.</span></span>
<span id="cb7-16"><a href="#cb7-16"></a>column_transform <span class="op">=</span> ColumnTransformer([(<span class="st">"bag_of_chars"</span>, bag_of_chars, <span class="st">"review"</span>)])</span>
<span id="cb7-17"><a href="#cb7-17"></a></span>
<span id="cb7-18"><a href="#cb7-18"></a><span class="co"># Create our pipeline.</span></span>
<span id="cb7-19"><a href="#cb7-19"></a>pipeline <span class="op">=</span> Pipeline(</span>
<span id="cb7-20"><a href="#cb7-20"></a>    [</span>
<span id="cb7-21"><a href="#cb7-21"></a>        (<span class="st">"bag_chars"</span>, column_transform),</span>
<span id="cb7-22"><a href="#cb7-22"></a>        (<span class="st">"oner"</span>, OneR())</span>
<span id="cb7-23"><a href="#cb7-23"></a>    ]</span>
<span id="cb7-24"><a href="#cb7-24"></a>)</span>
<span id="cb7-25"><a href="#cb7-25"></a></span>
<span id="cb7-26"><a href="#cb7-26"></a><span class="co"># Train it!</span></span>
<span id="cb7-27"><a href="#cb7-27"></a>pipeline.fit(X, y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now after all that work, how’d we do?</p>
<div id="170d1dfe-dcea-4fa5-9f14-68dcba741a98" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a>X_test, y_test <span class="op">=</span> test_df[features], test_df[labels]</span>
<span id="cb8-2"><a href="#cb8-2"></a>pipeline.score(X_test, y_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>0.5812817904374364</code></pre>
</div>
</div>
<p>58% accuracy, that’s a big improvement over the 50% accuracy our baseline model has!</p>
</section>
<section id="machine-learning-is-an-end-to-end-process" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="machine-learning-is-an-end-to-end-process"><span class="header-section-number">4.3</span> Machine learning is an end to end process</h2>
<p>We barely touched the model and ended up with an 8% improvement just by improving the preprocessing step. There are multiple steps to building a model, from collecting data through model training and they are all important for the final outcome. I probably sound like a broken record at this point, but this is why we started with a baseline model. The process of building a model is really one of experimentation. You make a change here then test it. Now a change there and test it. It’s tweak after tweak, but you need to know how those tweaks affect the performance.</p>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-Holte1993" class="csl-entry" role="listitem">
Holte, Robert C. 1993. <span>“Very Simple Classification Rules Perform Well on Most Commonly Used Datasets.”</span> <em>Machine Learning</em> 11 (1): 63–90. <a href="https://doi.org/10.1023/A:1022631118932">https://doi.org/10.1023/A:1022631118932</a>.
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../chapter/03_oner/oner.html" class="pagination-link" aria-label="OneR">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">OneR</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../chapter/bonus/cleaning_data/cleaning_data.html" class="pagination-link" aria-label="Bonus: cleaning data">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Bonus: cleaning data</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>